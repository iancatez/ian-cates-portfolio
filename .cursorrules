# Cursor Rules for Portfolio Project

## Component Library: ShadCN UI Only

**CRITICAL**: This project MUST use ShadCN UI components exclusively. Do NOT create custom UI components that replicate ShadCN functionality.

### ShadCN Component Usage Rules

1. **Always use ShadCN components** from `@/components/ui/` for UI elements:
   - Buttons: Use `Button` from `@/components/ui/button`
   - Cards: Use `Card`, `CardHeader`, `CardContent`, etc. from `@/components/ui/card`
   - Forms: Use ShadCN form components (install if needed)
   - Dialogs, Modals, Dropdowns: Install and use ShadCN versions
   - Any other UI element: Check ShadCN docs first, install if available

2. **Installing New ShadCN Components**:
   - Use: `npx shadcn@latest add [component-name]`
   - Check available components at: https://ui.shadcn.com/docs/components
   - Never create custom versions of components that exist in ShadCN

3. **Custom Components**:
   - Only create custom components for:
     - Business logic components (e.g., `ProjectCard`, `HeroSection`)
     - Layout components (e.g., `Navigation`, `Footer`)
     - Compositions of ShadCN components
   - Custom components MUST use ShadCN components internally
   - Never recreate ShadCN functionality (buttons, cards, inputs, etc.)

4. **Styling Rules**:
   - Use Tailwind CSS utility classes for styling
   - Use ShadCN's `cn()` utility from `@/lib/utils` for conditional classes
   - Follow ShadCN's design patterns and spacing
   - Use ShadCN CSS variables for colors (defined in `globals.css`)

5. **When ShadCN Doesn't Have a Component**:
   - First: Check if a similar component exists that can be customized
   - Second: Check ShadCN community examples or variants
   - Last Resort: Create minimal custom component using ShadCN primitives
   - Always document why a custom component was needed

## TypeScript Best Practices

### Type Safety
- **Always type function parameters and return types**
- **Use explicit types for props interfaces**
- **Avoid `any` type** - use `unknown` if type is truly unknown, then narrow it
- **Use type inference** only when types are obvious from context
- **Define interfaces for component props** - use `interface` for extensible types, `type` for unions/intersections

### Component Props
```tsx
// ✅ GOOD: Explicit interface
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
}

export function Button({ label, onClick, variant = 'primary', disabled = false }: ButtonProps) {
  // ...
}

// ❌ BAD: No types
export function Button(props) {
  // ...
}
```

### Type Definitions
- **Use `interface` for object shapes** that might be extended
- **Use `type` for unions, intersections, and computed types**
- **Export types/interfaces** that are used across files
- **Use `Readonly<>` or `as const`** for immutable data
- **Use utility types**: `Partial<>`, `Pick<>`, `Omit<>`, `Required<>`

### Next.js Specific Types
- **Use `Metadata` type** from `next` for page metadata
- **Type page params** with `{ params: { id: string } }`
- **Use `React.ReactNode`** for children props
- **Type API routes** with proper request/response types

### Error Handling
- **Type error objects** properly
- **Use type guards** for runtime type checking
- **Avoid type assertions** (`as`) unless absolutely necessary

### Examples
```tsx
// ✅ GOOD: Proper typing
interface ProjectCardProps {
  title: string;
  description: string;
  technologies: readonly string[];
  onView?: (id: string) => void;
}

// ✅ GOOD: Type guard
function isError(error: unknown): error is Error {
  return error instanceof Error;
}

// ✅ GOOD: Utility types
type PartialProject = Partial<Project>;
type ProjectPreview = Pick<Project, 'title' | 'description'>;
```

## Tailwind CSS Best Practices

### Class Organization
- **Order classes logically**: Layout → Spacing → Typography → Colors → Effects
- **Use consistent spacing scale**: Stick to Tailwind's spacing scale (0.5, 1, 1.5, 2, 3, 4, 6, 8, etc.)
- **Group related classes** with comments if needed for readability

### Responsive Design
- **Mobile-first approach**: Base styles for mobile, then add breakpoints
- **Use responsive prefixes**: `sm:`, `md:`, `lg:`, `xl:`, `2xl:`
- **Test on multiple screen sizes** before committing

### Class Naming and Reusability
- **Prefer utility classes** over custom CSS
- **Use `cn()` utility** for conditional classes (from `@/lib/utils`)
- **Extract repeated patterns** into components, not CSS classes
- **Avoid arbitrary values** unless necessary: prefer `w-64` over `w-[256px]`

### Performance
- **Avoid dynamic class construction** in render - use `cn()` instead
- **Use `@apply` sparingly** - only for repeated patterns in CSS files
- **Purge unused classes** - Tailwind does this automatically in production
- **Prefer composition** over long class strings

### ShadCN Integration
- **Use ShadCN CSS variables** for colors: `bg-background`, `text-foreground`, etc.
- **Follow ShadCN spacing patterns** when customizing components
- **Use semantic color names**: `bg-primary`, `text-muted-foreground`, etc.

### Examples
```tsx
// ✅ GOOD: Organized, responsive, using cn()
import { cn } from "@/lib/utils"

<div className={cn(
  "flex flex-col gap-4",           // Layout
  "p-6 md:p-8",                    // Spacing (responsive)
  "bg-card text-card-foreground",   // Colors (ShadCN variables)
  "rounded-lg shadow-sm",          // Effects
  className                         // Allow override
)}>

// ❌ BAD: Disorganized, no responsive, hardcoded values
<div className="bg-white text-black p-[24px] rounded-[8px] flex flex-col gap-[16px]">
```

### Dark Mode
- **Use ShadCN color variables** which handle dark mode automatically
- **Test dark mode** appearance
- **Respect user preference** - don't force dark/light mode

## Code Style

- **TypeScript**: Strict mode enabled, always type props and functions
- **Components**: Use functional components with TypeScript
- **File Naming**: PascalCase for components (e.g., `ProjectCard.tsx`), kebab-case for utilities
- **Imports**: Use path aliases (`@/components`, `@/lib`, etc.)
- **Import Order**: External → Internal, grouped by type
- **Formatting**: Follow existing code style, use consistent indentation (2 spaces)

### Import Organization
```tsx
// ✅ GOOD: Organized imports
import { type Metadata } from "next"              // External, types
import { useState, useEffect } from "react"       // External, hooks
import { Button } from "@/components/ui/button"   // Internal, components
import { cn } from "@/lib/utils"                  // Internal, utilities
import type { Project } from "@/types"            // Internal, types
```

## Next.js Best Practices

### App Router Patterns
- **Use Server Components by default** - only use `'use client'` when needed
- **Mark client components** with `'use client'` directive at the top
- **Use async Server Components** for data fetching
- **Leverage loading.tsx and error.tsx** for better UX
- **Use route groups** `(folder)` for organization without affecting URLs

### Data Fetching
- **Use async/await** in Server Components
- **Fetch data at the component level** that needs it
- **Use `cache()` and `unstable_cache()`** for request deduplication
- **Handle errors gracefully** with error boundaries

### Performance
- **Use `next/image`** for all images
- **Lazy load components** with `dynamic()` when appropriate
- **Optimize fonts** with `next/font`
- **Use `generateStaticParams`** for static pages when possible
- **Implement proper loading states**

### Examples
```tsx
// ✅ GOOD: Server Component with async
export default async function ProjectsPage() {
  const projects = await fetchProjects()
  return <ProjectsList projects={projects} />
}

// ✅ GOOD: Client Component marked properly
'use client'
import { useState } from 'react'
export function InteractiveComponent() {
  // ...
}
```

## React Best Practices

### Component Design
- **Keep components small and focused** - single responsibility
- **Use composition** over prop drilling
- **Extract custom hooks** for reusable logic
- **Memoize expensive computations** with `useMemo`
- **Use `useCallback`** for functions passed as props

### State Management
- **Lift state up** only when necessary
- **Use local state** when possible
- **Consider Context** for deeply nested prop passing
- **Avoid premature optimization** - profile first

### Hooks Rules
- **Only call hooks at the top level** - not in loops/conditions
- **Custom hooks must start with `use`**
- **Return consistent values** from custom hooks
- **Handle cleanup** in `useEffect` when needed

### Examples
```tsx
// ✅ GOOD: Custom hook
function useProjects() {
  const [projects, setProjects] = useState<Project[]>([])
  const [loading, setLoading] = useState(true)
  
  useEffect(() => {
    fetchProjects().then(setProjects).finally(() => setLoading(false))
  }, [])
  
  return { projects, loading }
}

// ✅ GOOD: Memoized expensive computation
const sortedProjects = useMemo(
  () => projects.sort((a, b) => a.title.localeCompare(b.title)),
  [projects]
)
```

## Animation Guidelines

- **Use Framer Motion** for animations
- **Keep animations subtle and performant** - target 60fps
- **Respect `prefers-reduced-motion`** media query
- **Use GPU-accelerated properties**: `transform` and `opacity`
- **Avoid animating `width`, `height`, `top`, `left`** - use `transform` instead
- **Debounce mouse event handlers** for performance
- **Use `will-change` sparingly** - only for elements that will animate

### Animation Examples
```tsx
// ✅ GOOD: GPU-accelerated animation
<motion.div
  initial={{ opacity: 0, y: 20 }}
  animate={{ opacity: 1, y: 0 }}
  transition={{ duration: 0.3 }}
>

// ❌ BAD: Animating layout properties
// Don't animate width/height directly
```

## Performance Best Practices

### Code Splitting
- **Use dynamic imports** for heavy components
- **Lazy load routes** when appropriate
- **Split large bundles** automatically with Next.js

### Optimization
- **Optimize images** with `next/image`
- **Minimize bundle size** - check what's being imported
- **Use React.memo** for expensive components that re-render often
- **Avoid unnecessary re-renders** - check dependencies in hooks
- **Profile before optimizing** - measure first

### Loading States
- **Always show loading states** for async operations
- **Use Suspense boundaries** for better UX
- **Implement skeleton screens** for better perceived performance

## Accessibility Best Practices

### Semantic HTML
- **Use proper HTML elements**: `<nav>`, `<main>`, `<section>`, `<article>`, etc.
- **Use heading hierarchy** correctly (h1 → h2 → h3)
- **Provide alt text** for all images
- **Use ARIA labels** when semantic HTML isn't sufficient

### Keyboard Navigation
- **Ensure all interactive elements** are keyboard accessible
- **Visible focus indicators** for keyboard navigation
- **Logical tab order** throughout the page
- **Skip links** for main content

### Screen Readers
- **Use descriptive link text** - avoid "click here"
- **Provide form labels** for all inputs
- **Announce dynamic content** with ARIA live regions
- **Test with screen readers**

### Examples
```tsx
// ✅ GOOD: Accessible button
<Button aria-label="Close dialog" onClick={handleClose}>
  <XIcon aria-hidden="true" />
</Button>

// ✅ GOOD: Proper heading structure
<main>
  <h1>Page Title</h1>
  <section>
    <h2>Section Title</h2>
  </section>
</main>
```

## Code Quality Standards

### Error Handling
- **Handle errors gracefully** - never let errors crash the app
- **Provide user-friendly error messages**
- **Log errors** for debugging (but not sensitive data)
- **Use error boundaries** for React errors

### Testing Considerations
- **Write testable code** - pure functions when possible
- **Use descriptive variable and function names**
- **Add comments** for complex logic, not obvious code
- **Keep functions pure** when possible

### Documentation
- **Document complex functions** with JSDoc comments
- **Explain "why" not "what"** in comments
- **Keep README updated** with setup instructions
- **Document component props** with TypeScript interfaces

### Git Practices
- **Write clear commit messages** - use conventional commits format
- **Keep commits focused** - one logical change per commit
- **Review code** before committing
- **Test before committing** - ensure build succeeds

## Project Structure

```
app/              # Next.js App Router pages
components/       # React components
  ui/            # ShadCN components (auto-generated, don't edit directly)
  [custom].tsx   # Custom business logic components
lib/             # Utilities and helpers
hooks/           # Custom React hooks
```

## Before Creating Any UI Component

1. **Check ShadCN first**: https://ui.shadcn.com/docs/components
2. **Search existing components**: Check if we already have it
3. **Install from ShadCN**: Use `npx shadcn@latest add [component]`
4. **Customize ShadCN**: Modify the installed component if needed (it's in your codebase)
5. **Compose with ShadCN**: Build complex components using ShadCN primitives

## Examples

✅ **GOOD**: Using ShadCN Button
```tsx
import { Button } from "@/components/ui/button"

<Button variant="outline" size="lg">Click me</Button>
```

✅ **GOOD**: Custom component using ShadCN
```tsx
import { Card, CardContent } from "@/components/ui/card"
import { Button } from "@/components/ui/button"

export function ProjectCard({ title, description }) {
  return (
    <Card>
      <CardContent>
        <h3>{title}</h3>
        <p>{description}</p>
        <Button>View Project</Button>
      </CardContent>
    </Card>
  )
}
```

❌ **BAD**: Creating custom button
```tsx
// DON'T DO THIS - Use ShadCN Button instead
export function CustomButton() {
  return <button className="...">Click</button>
}
```

## File Organization

### Directory Structure
```
app/                    # Next.js App Router pages
  layout.tsx           # Root layout
  page.tsx             # Home page
  [route]/             # Route pages
components/            # React components
  ui/                  # ShadCN components (don't edit directly)
  [name].tsx           # Custom components
lib/                   # Utilities and helpers
  utils.ts             # Utility functions (cn, etc.)
  [name].ts            # Other utilities
hooks/                 # Custom React hooks
  use-[name].ts        # Hook files
types/                 # TypeScript type definitions
  index.ts             # Shared types
public/                # Static assets
```

### Naming Conventions
- **Components**: PascalCase (`ProjectCard.tsx`)
- **Hooks**: camelCase with `use` prefix (`useProjects.ts`)
- **Utilities**: camelCase (`formatDate.ts`)
- **Types**: PascalCase (`Project.ts`, `UserData.ts`)
- **Constants**: UPPER_SNAKE_CASE (`API_BASE_URL`)

## Reminders

### Before Writing Code
1. **Check ShadCN documentation** before creating UI components
2. **Type everything** - no `any` types
3. **Follow Tailwind best practices** - mobile-first, use utilities
4. **Consider accessibility** - semantic HTML, ARIA labels
5. **Think about performance** - optimize images, lazy load when needed

### Code Review Checklist
- [ ] All TypeScript types are defined
- [ ] Uses ShadCN components (not custom UI)
- [ ] Tailwind classes are organized and responsive
- [ ] Accessibility considerations met
- [ ] Performance optimized (images, lazy loading)
- [ ] Error handling implemented
- [ ] Code is readable and well-commented
- [ ] Build succeeds without errors
- [ ] No console errors or warnings

### Quick Reference
- **ShadCN Docs**: https://ui.shadcn.com/docs/components
- **Tailwind Docs**: https://tailwindcss.com/docs
- **Next.js Docs**: https://nextjs.org/docs
- **TypeScript Handbook**: https://www.typescriptlang.org/docs/
- **React Docs**: https://react.dev

